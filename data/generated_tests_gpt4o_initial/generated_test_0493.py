from datetime import datetime
import random
import matplotlib.pyplot as plt
import unittest


def task_func(
    epoch_milliseconds,
    teams=["Team1", "Team2", "Team3", "Team4", "Team5"],
    random_seed=0,
):
    """
    Generate and plot a performance trend for different teams from a given epoch timestamp to the current time.

    The performance data is generated by creating a series of random values for each day from the starting timestamp
    to the present day. Each team's performance is simulated as a random float between 0.1 and 1 for each day.
    The plot shows days since the start date on the x-axis and performance on the y-axis.

    Parameters:
    epoch_milliseconds (int): The epoch milliseconds from where to start the generation. Must not be in the future.
    teams (list of str, optional): Team names. If not provided, defaults to ['Team1', 'Team2', 'Team3', 'Team4', 'Team5'].
    random_seed (int, optional): Seed for random number generation to ensure reproducibility. Defaults to 0.

    Returns:
    dict: A dictionary containing performance data for each team, with days as indices and performance as float values.
    matplotlib.figure.Figure: A figure object showing the performance trend of each team over the days.

    Requirements:
    - datetime.datetime
    - random
    - matplotlib

    Example:
    >>> results, ax = task_func(1236472051807)
    >>> results.keys()
    dict_keys(['Team1', 'Team2', 'Team3', 'Team4', 'Team5'])
    >>> type(ax)
    <class 'matplotlib.figure.Figure'>
    """

    random.seed(random_seed)

    if (not isinstance(teams, list)) or (not all(isinstance(t, str) for t in teams)):
        raise TypeError("Expected teams to be list of str")

    start_time = datetime.fromtimestamp(epoch_milliseconds / 1000.0)
    current_time = datetime.now()
    days_diff = (current_time - start_time).days

    if days_diff < 0:
        raise ValueError("Input epoch timestamp is in the future!")

    performance_data = {team: [0] * days_diff for team in teams}

    for i in range(days_diff):
        for team in teams:
            performance = random.uniform(0.1, 1)
            performance_data[team][i] += performance

    fig, ax = plt.subplots()
    for team, performance in performance_data.items():
        ax.plot(range(days_diff), performance, label=team)

    ax.set_xlabel("Days since " + start_time.strftime("%Y-%m-%d %H:%M:%S"))
    ax.set_ylabel("Performance")
    ax.legend()

    return performance_data, fig


class TestTaskFunc(unittest.TestCase):

    def test_empty_teams(self):
        with self.assertRaises(TypeError):
            task_func(1236472051807, teams="InvalidTeams")

    def test_valid_teams(self):
        results, ax = task_func(1236472051807, teams=["TeamA", "TeamB"])
        self.assertIn("TeamA", results)
        self.assertIn("TeamB", results)

    def test_performance_data_structure(self):
        results, _ = task_func(1236472051807)
        self.assertIsInstance(results, dict)
        for team in results.keys():
            self.assertIsInstance(results[team], list)

    def test_future_timestamp(self):
        future_time = int((datetime.now().timestamp() + 10000) * 1000)
        with self.assertRaises(ValueError):
            task_func(future_time)

    def test_random_seed_reproducibility(self):
        results1, _ = task_func(1236472051807, random_seed=1)
        results2, _ = task_func(1236472051807, random_seed=1)
        self.assertEqual(results1, results2)


if __name__ == '__main__':
    unittest.main()